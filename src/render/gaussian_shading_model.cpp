#include"shading_model.h"
#include"d3d_helper.h"
#include<assert.h>
#include "d3d12shader.h"
#include "dxcapi.h"
#include "view_info.h"
#include "render_proxy.h"
#include<cmath>

static void CheckResult(HRESULT result, Microsoft::WRL::ComPtr<ID3DBlob> error_blob)
{
	if (FAILED(result))
	{
		if (error_blob)
		{
			OutputDebugStringA((char*)error_blob->GetBufferPointer());
		}
	}
}

static void CompileShaingModel6(LPCWSTR* pszArgs,int args_num, LPCWSTR source_file, Microsoft::WRL::ComPtr<IDxcBlob>& pShader)
{
	Microsoft::WRL::ComPtr<IDxcUtils> pUtils;
	Microsoft::WRL::ComPtr<IDxcCompiler3> pCompiler;
	DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
	DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

	// Create default include handler. 
	Microsoft::WRL::ComPtr<IDxcIncludeHandler> pIncludeHandler;
	pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

	Microsoft::WRL::ComPtr<IDxcBlobEncoding> pSource = nullptr;
	pUtils->LoadFile(source_file, nullptr, &pSource);
	DxcBuffer Source;
	Source.Ptr = pSource->GetBufferPointer();
	Source.Size = pSource->GetBufferSize();
	Source.Encoding = DXC_CP_ACP;
	Microsoft::WRL::ComPtr<IDxcResult> pResults;
	pCompiler->Compile(
		&Source,                // Source buffer.
		pszArgs,                // Array of pointers to arguments.
		args_num,      // Number of arguments.
		pIncludeHandler.Get(),        // User-provided interface to handle #include directives (optional).
		IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
	);
	Microsoft::WRL::ComPtr<IDxcBlobUtf8> pErrors = nullptr;
	pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
	// Note that d3dcompiler would return null if no errors or warnings are present.
	// IDxcCompiler3::Compile will always return an error buffer, but its length
	// will be zero if there are no warnings or errors.
	if (pErrors != nullptr && pErrors->GetStringLength() != 0)
		OutputDebugStringA(pErrors->GetStringPointer());

	HRESULT hrStatus;
	pResults->GetStatus(&hrStatus);
	if (FAILED(hrStatus))
	{
		OutputDebugStringA("Compilation Failed\n");
		return;
	}

	//
// Save shader binary.
//
	Microsoft::WRL::ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
	pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
	if (pShader != nullptr)
	{
		FILE* fp = NULL;

		_wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
		fwrite(pShader->GetBufferPointer(), pShader->GetBufferSize(), 1, fp);
		fclose(fp);
	}

	//
	// Save pdb.
	//
	Microsoft::WRL::ComPtr<IDxcBlob> pPDB = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlobUtf16> pPDBName = nullptr;
	pResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
	{
		FILE* fp = NULL;

		// Note that if you don't specify -Fd, a pdb name will be automatically generated.
		// Use this file name to save the pdb so that PIX can find it quickly.
		_wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
		fwrite(pPDB->GetBufferPointer(), pPDB->GetBufferSize(), 1, fp);
		fclose(fp);
	}

}

GaussianSplattingShadingModel::GaussianSplattingShadingModel()
{
	return;
}

void GaussianSplattingShadingModel::InitShaders()
{

	{
		LPCWSTR hlsl_file_name = L"./shader/gaussian_splatting/clear_perpixel_linked_list.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"CSMain",              // Entry point.
			L"-T", L"cs_6_0",            // Target.
			L"-Zi",L"-Qembed_debug",        // Enable debug information (slim format)
			//L"-Od",
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/gaussian_splatting/clear_perpixel_linked_list.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/gaussian_splatting/clear_perpixel_linked_list.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_clear_ppll_cs);
	}

	{
		LPCWSTR hlsl_file_name = L"./shader/gaussian_splatting/GaussianMS.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"main",              // Entry point.
			L"-T", L"ms_6_5",            // Target.
			L"-Zi", L"-Qembed_debug",                     // Enable debug information (slim format)
			//L"-Od",
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/gaussian_splatting/GaussianMS.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/gaussian_splatting/GaussianMS.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_create_ppll_ms);
	}

	{
		LPCWSTR hlsl_file_name = L"./shader/gaussian_splatting/GaussianPS_PPLL.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"PSMain",              // Entry point.
			L"-T", L"ps_6_0",            // Target.
			L"-Zi",L"-Qembed_debug",                      // Enable debug information (slim format)
			//L"-Od",
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/gaussian_splatting/GaussianPS_PPLL.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/gaussian_splatting/GaussianPS_PPLL.cso",
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_create_ppll_ps);
	}

	{
		LPCWSTR hlsl_file_name = L"./shader/gaussian_splatting/DrawCS.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"CSMain",              // Entry point.
			L"-T", L"cs_6_0",            // Target.
			L"-Zi",L"-Qembed_debug",        // Enable debug information (slim format)
			L"-Od",
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/gaussian_splatting/DrawCS.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/gaussian_splatting/DrawCS.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_render_ppll_cs);
	}

}

void GaussianSplattingShadingModel::InitPSO()
{
	//clear ppll
	{
		D3D12_COMPUTE_PIPELINE_STATE_DESC pso_desc = {};
		pso_desc.pRootSignature = m_root_signature_create_ppll.Get();
		pso_desc.CS.pShaderBytecode = m_clear_ppll_cs->GetBufferPointer();
		pso_desc.CS.BytecodeLength = m_clear_ppll_cs->GetBufferSize();
		pso_desc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;
		ThrowIfFailed(D3dResources::GetDevice()->CreateComputePipelineState(&pso_desc, IID_PPV_ARGS(&m_clear_ppll_pso)));
	}

	//create ppll
	{
		//blend
		D3D12_BLEND_DESC blend_desc = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
		blend_desc.RenderTarget[0].BlendEnable = true;
		blend_desc.RenderTarget[0].LogicOpEnable = FALSE;
		blend_desc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_COLOR;
		blend_desc.RenderTarget[0].DestBlend = D3D12_BLEND_DEST_COLOR;
		blend_desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blend_desc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
		blend_desc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_SRC_ALPHA;
		blend_desc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_INV_SRC_ALPHA;
		blend_desc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blend_desc.RenderTarget[0].LogicOp = D3D12_LOGIC_OP_NOOP;
		//depth:disable Depth Wirte & enable Depth Test
		D3D12_DEPTH_STENCIL_DESC depth_stencil_desc;
		depth_stencil_desc.DepthEnable = true;
		depth_stencil_desc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
		depth_stencil_desc.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
		depth_stencil_desc.StencilEnable = false;

		D3DX12_MESH_SHADER_PIPELINE_STATE_DESC pso_desc = {};
		pso_desc.pRootSignature = m_root_signature_create_ppll.Get();
		pso_desc.MS = CD3DX12_SHADER_BYTECODE(m_create_ppll_ms.Get());
		pso_desc.PS = CD3DX12_SHADER_BYTECODE(m_create_ppll_ps.Get());
		pso_desc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
		pso_desc.NumRenderTargets = 0;
		pso_desc.RTVFormats[0] = DXGI_FORMAT_UNKNOWN;
		pso_desc.DSVFormat = DXGI_FORMAT_D32_FLOAT;
		pso_desc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);   
		pso_desc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE; // do not cull back!!
		pso_desc.BlendState = blend_desc;         // transparent
		pso_desc.DepthStencilState = depth_stencil_desc;
		pso_desc.SampleMask = UINT_MAX;
		pso_desc.SampleDesc = DefaultSampleDesc();

		auto psoStream = CD3DX12_PIPELINE_MESH_STATE_STREAM(pso_desc);
		D3D12_PIPELINE_STATE_STREAM_DESC streamDesc;
		streamDesc.pPipelineStateSubobjectStream = &psoStream;
		streamDesc.SizeInBytes = sizeof(psoStream);
		ThrowIfFailed(D3dResources::GetDevice()->CreatePipelineState(&streamDesc, IID_PPV_ARGS(&m_create_ppll_pso)));
	}

	//render ppll
	{
		D3D12_COMPUTE_PIPELINE_STATE_DESC pso_desc = {};
		pso_desc.pRootSignature = m_root_signature_render_ppll.Get();
		pso_desc.CS.pShaderBytecode = m_render_ppll_cs->GetBufferPointer();
		pso_desc.CS.BytecodeLength = m_render_ppll_cs->GetBufferSize();
		pso_desc.Flags = D3D12_PIPELINE_STATE_FLAG_NONE;
		ThrowIfFailed(D3dResources::GetDevice()->CreateComputePipelineState(&pso_desc, IID_PPV_ARGS(&m_render_ppll_pso)));
	}
}
void GaussianSplattingShadingModel::InitResources()
{
	//create resource
	int max_pixel_num = MAX_SCREEN_SIZE.x * MAX_SCREEN_SIZE.y;
	auto startoffset_buffer_desc = CD3DX12_RESOURCE_DESC::Buffer(max_pixel_num * sizeof(int), D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
	auto node_buffer_desc = CD3DX12_RESOURCE_DESC::Buffer(max_pixel_num * 128 * sizeof(PerPixelLinkedList_Node), D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
	auto counter_desc = CD3DX12_RESOURCE_DESC::Buffer(sizeof(int), D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
	auto target_desc = CD3DX12_RESOURCE_DESC::Tex2D(DXGI_FORMAT_R8G8B8A8_UNORM, MAX_SCREEN_SIZE.x, MAX_SCREEN_SIZE.y,1,1,1,0, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
	auto gaussian_texture_desc = CD3DX12_RESOURCE_DESC::Tex2D(DXGI_FORMAT_R32_FLOAT, GAUSSIAN_TEXTURE_SIZE.x, GAUSSIAN_TEXTURE_SIZE.y,1,1,1,0);
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, &counter_desc,
		D3D12_RESOURCE_STATE_COMMON, nullptr, IID_PPV_ARGS(&m_frame_resources.node_counter)));
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, &startoffset_buffer_desc,
		D3D12_RESOURCE_STATE_COMMON, nullptr, IID_PPV_ARGS(&m_frame_resources.start_offset_buffer)));
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, &node_buffer_desc,
		D3D12_RESOURCE_STATE_COMMON, nullptr, IID_PPV_ARGS(&m_frame_resources.node_buffer)));
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, &target_desc,
		D3D12_RESOURCE_STATE_COMMON, nullptr, IID_PPV_ARGS(&m_frame_resources.target_buffer)));
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, &gaussian_texture_desc,
		D3D12_RESOURCE_STATE_COPY_DEST, nullptr, IID_PPV_ARGS(&m_frame_resources.gaussian_texture_buffer)));
	m_frame_resources.bUpload = false;

	//init heap
	D3D12_DESCRIPTOR_HEAP_DESC heap_desc = {};
	heap_desc.NumDescriptors = 1024;
	heap_desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	heap_desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descriptor_heap.Init(heap_desc);

	//craete uav and srv
	D3D12_UNORDERED_ACCESS_VIEW_DESC startoffset_uav_desc;
	startoffset_uav_desc.Format = DXGI_FORMAT_R32_TYPELESS;
	startoffset_uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	startoffset_uav_desc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_RAW;
	startoffset_uav_desc.Buffer.FirstElement = 0;
	startoffset_uav_desc.Buffer.NumElements = max_pixel_num;
	startoffset_uav_desc.Buffer.CounterOffsetInBytes = 0;
	startoffset_uav_desc.Buffer.StructureByteStride = 0;

	D3D12_SHADER_RESOURCE_VIEW_DESC startoffset_srv_desc;
	startoffset_srv_desc.Format = DXGI_FORMAT_R32_SINT;
	startoffset_srv_desc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	startoffset_srv_desc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
	startoffset_srv_desc.Buffer.FirstElement = 0;
	startoffset_srv_desc.Buffer.NumElements = max_pixel_num;
	startoffset_srv_desc.Buffer.StructureByteStride = 0;
	startoffset_srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

	D3D12_UNORDERED_ACCESS_VIEW_DESC node_buffer_uav_desc;
	node_buffer_uav_desc.Format = DXGI_FORMAT_UNKNOWN;
	node_buffer_uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	node_buffer_uav_desc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;
	node_buffer_uav_desc.Buffer.FirstElement = 0;
	node_buffer_uav_desc.Buffer.NumElements = max_pixel_num * 128;
	node_buffer_uav_desc.Buffer.CounterOffsetInBytes = 0;
	node_buffer_uav_desc.Buffer.StructureByteStride = sizeof(PerPixelLinkedList_Node);

	D3D12_SHADER_RESOURCE_VIEW_DESC node_buffer_srv_desc;
	node_buffer_srv_desc.Format = DXGI_FORMAT_UNKNOWN;
	node_buffer_srv_desc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	node_buffer_srv_desc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
	node_buffer_srv_desc.Buffer.FirstElement = 0;
	node_buffer_srv_desc.Buffer.NumElements = max_pixel_num * 128;
	node_buffer_srv_desc.Buffer.StructureByteStride = sizeof(PerPixelLinkedList_Node);
	node_buffer_srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

	D3D12_UNORDERED_ACCESS_VIEW_DESC node_counter_uav_desc;
	node_counter_uav_desc.Format = DXGI_FORMAT_R32_SINT;
	node_counter_uav_desc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	node_counter_uav_desc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;
	node_counter_uav_desc.Buffer.FirstElement = 0;
	node_counter_uav_desc.Buffer.NumElements = 1;
	node_counter_uav_desc.Buffer.CounterOffsetInBytes = 0;
	node_counter_uav_desc.Buffer.StructureByteStride = 0;

	D3D12_SHADER_RESOURCE_VIEW_DESC gaussian_texture_srv_desc;
	gaussian_texture_srv_desc.Format = DXGI_FORMAT_R32_FLOAT;
	gaussian_texture_srv_desc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	gaussian_texture_srv_desc.Texture2D.MipLevels = -1;
	gaussian_texture_srv_desc.Texture2D.PlaneSlice = 0;
	gaussian_texture_srv_desc.Texture2D.MostDetailedMip = 0;
	gaussian_texture_srv_desc.Texture2D.ResourceMinLODClamp = 0;
	gaussian_texture_srv_desc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;


	D3D12_UNORDERED_ACCESS_VIEW_DESC target_uav_desc;
	target_uav_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	target_uav_desc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
	target_uav_desc.Texture2D.MipSlice = 0;
	target_uav_desc.Texture2D.PlaneSlice = 0;

	//slot 0-1: input srv
	// slot 2 :gaussian texture srv
	D3dResources::GetDevice()->CreateShaderResourceView(m_frame_resources.gaussian_texture_buffer.Get(), &gaussian_texture_srv_desc, descriptor_heap[2]);
	//slot 3:5: uav for create ppll
	D3dResources::GetDevice()->CreateUnorderedAccessView(m_frame_resources.start_offset_buffer.Get(), nullptr, &startoffset_uav_desc, descriptor_heap[3]);
	D3dResources::GetDevice()->CreateUnorderedAccessView(m_frame_resources.node_buffer.Get(), m_frame_resources.node_counter.Get(), &node_buffer_uav_desc, descriptor_heap[4]);
	D3dResources::GetDevice()->CreateUnorderedAccessView(m_frame_resources.node_counter.Get(), nullptr, &node_counter_uav_desc, descriptor_heap[5]);
	
	//slot 6-8: srv for render ppll
	D3dResources::GetDevice()->CreateShaderResourceView(m_frame_resources.start_offset_buffer.Get(), &startoffset_srv_desc, descriptor_heap[6]);
	D3dResources::GetDevice()->CreateShaderResourceView(m_frame_resources.node_buffer.Get(), &node_buffer_srv_desc, descriptor_heap[7]);
	D3dResources::GetDevice()->CreateShaderResourceView(m_frame_resources.gaussian_texture_buffer.Get(), &gaussian_texture_srv_desc, descriptor_heap[8]);
	//slot 9:uav for render ppll
	D3dResources::GetDevice()->CreateUnorderedAccessView(m_frame_resources.target_buffer.Get(), nullptr, &target_uav_desc, descriptor_heap[9]);



}

void GaussianSplattingShadingModel::Init()
{
	InitShaders();
	InitResources();
	InitRootSignature();
	InitPSO();
}

void GaussianSplattingShadingModel::InitRootSignature()
{
	D3D12_STATIC_SAMPLER_DESC sampler = CD3DX12_STATIC_SAMPLER_DESC();
	sampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
	sampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
	sampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
	sampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER;
	sampler.MipLODBias = 0;
	sampler.MaxAnisotropy = 0;
	sampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	sampler.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
	sampler.MinLOD = 0.0f;
	sampler.MaxLOD = D3D12_FLOAT32_MAX;
	sampler.ShaderRegister = 0;
	sampler.RegisterSpace = 0;
	sampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

	//init create ppll root signature
	{
		CD3DX12_ROOT_PARAMETER rootParameters[3];
		rootParameters[ViewCBufferIndex].InitAsConstants(sizeof(ViewBuffer) / 4, 0, 0, D3D12_SHADER_VISIBILITY_ALL);
		rootParameters[BatchCBufferIndex].InitAsConstants(sizeof(BatchBuffer) / 4, 1, 0, D3D12_SHADER_VISIBILITY_MESH);
		CD3DX12_DESCRIPTOR_RANGE DescRange[2];
		DescRange[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 3, 0);//gaussian points srv and gaussian clusters srv
		DescRange[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 3, 1);//ppll uav
		rootParameters[2].InitAsDescriptorTable(2, DescRange, D3D12_SHADER_VISIBILITY_ALL);

		CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
		rootSignatureDesc.Init(_countof(rootParameters), rootParameters, 1, &sampler, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
		Microsoft::WRL::ComPtr<ID3DBlob> serialized_signature_desc;
		Microsoft::WRL::ComPtr<ID3DBlob> error;
		ThrowIfFailed(D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &serialized_signature_desc, &error));

		ThrowIfFailed(D3dResources::GetDevice()->CreateRootSignature(0, serialized_signature_desc->GetBufferPointer(), serialized_signature_desc->GetBufferSize(), IID_PPV_ARGS(&m_root_signature_create_ppll)));
	}
	//init render ppll root signature
	{
		CD3DX12_ROOT_PARAMETER rootParameters[2];
		rootParameters[0].InitAsConstants(sizeof(ViewBuffer) / 4, 0, 0, D3D12_SHADER_VISIBILITY_ALL);
		CD3DX12_DESCRIPTOR_RANGE DescRange[2];
		DescRange[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 3, 0);
		DescRange[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, 1, 0);
		rootParameters[1].InitAsDescriptorTable(2, DescRange, D3D12_SHADER_VISIBILITY_ALL);

		CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
		rootSignatureDesc.Init(_countof(rootParameters), rootParameters, 1, &sampler, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
		Microsoft::WRL::ComPtr<ID3DBlob> serialized_signature_desc;
		Microsoft::WRL::ComPtr<ID3DBlob> error;
		HRESULT result=D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &serialized_signature_desc, &error);
		CheckResult(result, error);
		ThrowIfFailed(D3dResources::GetDevice()->CreateRootSignature(0, serialized_signature_desc->GetBufferPointer(), serialized_signature_desc->GetBufferSize(), IID_PPV_ARGS(&m_root_signature_render_ppll)));
	}
}

void GaussianSplattingShadingModel::UploadTexture(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list)
{
	//init gaussian texture
	float* texture_cpu = new float[GAUSSIAN_TEXTURE_SIZE.x * GAUSSIAN_TEXTURE_SIZE.y];
	float mean_x = GAUSSIAN_TEXTURE_SIZE.x / 2;
	float mean_y = GAUSSIAN_TEXTURE_SIZE.y / 2;
	float axis_x = mean_x - 0.5f;
	float axis_y = mean_y - 0.5f;
	float cov_inv_00 = 2 * std::log(255) / (axis_x * axis_x);
	float cov_inv_11 = 2 * std::log(255) / (axis_y * axis_y);
	for (int x = 0; x < GAUSSIAN_TEXTURE_SIZE.x; x++)
	{
		for (int y = 0; y < GAUSSIAN_TEXTURE_SIZE.y; y++)
		{
			float delta_x = x + 0.5f - mean_x;
			float delta_y = y + 0.5f - mean_y;
			texture_cpu[y * GAUSSIAN_TEXTURE_SIZE.x + x] = std::exp(-0.5 * (cov_inv_00 * delta_x * delta_x + cov_inv_11 * delta_y * delta_y));
		}
	}

	const UINT64 uploadBufferSize = GetRequiredIntermediateSize(m_frame_resources.gaussian_texture_buffer.Get(), 0, 1);

	// Create the GPU upload buffer.
	ThrowIfFailed(D3dResources::GetDevice()->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(uploadBufferSize),
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&m_frame_resources.textureUploadHeap)));

	D3D12_SUBRESOURCE_DATA textureData = {};
	textureData.pData = texture_cpu;
	textureData.RowPitch = GAUSSIAN_TEXTURE_SIZE.x * sizeof(float);
	textureData.SlicePitch = textureData.RowPitch * GAUSSIAN_TEXTURE_SIZE.y;
	UpdateSubresources(command_list.Get(), m_frame_resources.gaussian_texture_buffer.Get(), m_frame_resources.textureUploadHeap.Get(), 0, 0, 1, &textureData);
	command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_frame_resources.gaussian_texture_buffer.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));
	m_frame_resources.bUpload = true;
	
}

void GaussianSplattingShadingModel::PopulateCommandList(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list, int buffer_index, const ViewInfo* p_view, const RenderProxy* p_render_proxy)
{
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList6> command_list6;
	command_list.As(&command_list6);
	const GaussianRenderProxy* p_proxy = dynamic_cast<const GaussianRenderProxy*>(p_render_proxy);
	assert(p_proxy);

	if (m_frame_resources.bUpload == false)
	{
		UploadTexture(command_list);
	}
	
	//////////////////////////////////clear ppll////////////////////////////////////
	command_list6->SetPipelineState(m_clear_ppll_pso.Get());
	command_list6->SetComputeRootSignature(m_root_signature_create_ppll.Get());
	ID3D12DescriptorHeap* pHeaps[] = { descriptor_heap.GetHeap().Get()};
	command_list6->SetDescriptorHeaps(1, pHeaps);
	command_list6->SetComputeRootDescriptorTable(2, descriptor_heap.GetGPU(0));
	command_list6->Dispatch(MAX_SCREEN_SIZE.x * MAX_SCREEN_SIZE.y / 512, 1, 1);

	D3D12_RESOURCE_BARRIER clear_barrier = {};
	clear_barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
	clear_barrier.UAV.pResource = m_frame_resources.node_buffer.Get();
	command_list6->ResourceBarrier(1, &clear_barrier);

	//////////////////////////////////craete ppll////////////////////////////////////
	command_list6->SetPipelineState(m_create_ppll_pso.Get());
	command_list->RSSetViewports(1, &p_view->m_viewport);
	command_list->RSSetScissorRects(1, &p_view->m_scissor_rect);
	command_list6->SetGraphicsRootSignature(m_root_signature_create_ppll.Get());
	ViewBuffer view_buffer;
	view_buffer.view_transform = p_view->view_matrix;
	view_buffer.project_transform = p_view->project_matrix;
	view_buffer.viewport_size = { int(p_view->m_viewport.Width),int(p_view->m_viewport.Height) };
	view_buffer.focal_xy = p_view->focal;
	BatchBuffer batch_buffer;
	batch_buffer.world_transform = p_render_proxy->world_transform;
	command_list6->SetGraphicsRoot32BitConstants(ViewCBufferIndex, sizeof(ViewBuffer) / 4, &view_buffer, 0);
	command_list6->SetGraphicsRoot32BitConstants(BatchCBufferIndex, sizeof(BatchBuffer) / 4, &batch_buffer, 0);
	D3dResources::GetDevice()->CopyDescriptorsSimple(2, descriptor_heap[0], p_proxy->device_static_resource->descriptor_heap[0], D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	command_list6->SetGraphicsRootDescriptorTable(2, descriptor_heap.GetGPU(0));
	command_list6->DispatchMesh(p_proxy->clusters_buffer.size(), 1, 1);

	D3D12_RESOURCE_BARRIER create_ppll_barrier = {};
	create_ppll_barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
	create_ppll_barrier.UAV.pResource = m_frame_resources.node_buffer.Get();
	command_list6->ResourceBarrier(1, &create_ppll_barrier);

	//////////////////////////////////render ppll////////////////////////////////////
	//command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_frame_resources.target_buffer.Get(), D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE));
	command_list6->SetPipelineState(m_render_ppll_pso.Get());
	command_list6->SetComputeRootSignature(m_root_signature_render_ppll.Get());
	command_list6->SetComputeRoot32BitConstants(0, sizeof(ViewBuffer) / 4, &view_buffer, 0);
	command_list6->SetComputeRootDescriptorTable(1, descriptor_heap.GetGPU(6));
	command_list6->Dispatch(std::ceil(MAX_SCREEN_SIZE.x/16.0f) , std::ceil(MAX_SCREEN_SIZE.y / 16.0f), 1);

	//command_list6->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::UAV(m_frame_resources.target_buffer.Get()));
	command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_frame_resources.target_buffer.Get(), D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_SOURCE));
	command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(p_view->render_target_buffer.Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COPY_DEST));
	command_list6->CopyResource(p_view->render_target_buffer.Get(), m_frame_resources.target_buffer.Get());
	command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(p_view->render_target_buffer.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_RENDER_TARGET));
	command_list->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_frame_resources.target_buffer.Get(), D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_COMMON));
}