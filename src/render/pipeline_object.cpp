#include "pipeline_object.h"
#include "d3d_helper.h"
#include "d3d12shader.h"
#include "dxcapi.h"
#include "render_proxy.h"
#include <assert.h>
#include <cmath>


void CompileShaingModel6(LPCWSTR* pszArgs, int args_num, LPCWSTR source_file, Microsoft::WRL::ComPtr<IDxcBlob>& pShader)
{
	Microsoft::WRL::ComPtr<IDxcUtils> pUtils;
	Microsoft::WRL::ComPtr<IDxcCompiler3> pCompiler;
	DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
	DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

	// Create default include handler. 
	Microsoft::WRL::ComPtr<IDxcIncludeHandler> pIncludeHandler;
	pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

	Microsoft::WRL::ComPtr<IDxcBlobEncoding> pSource = nullptr;
	pUtils->LoadFile(source_file, nullptr, &pSource);
	DxcBuffer Source;
	Source.Ptr = pSource->GetBufferPointer();
	Source.Size = pSource->GetBufferSize();
	Source.Encoding = DXC_CP_ACP;
	Microsoft::WRL::ComPtr<IDxcResult> pResults;
	pCompiler->Compile(
		&Source,                // Source buffer.
		pszArgs,                // Array of pointers to arguments.
		args_num,      // Number of arguments.
		pIncludeHandler.Get(),        // User-provided interface to handle #include directives (optional).
		IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
	);
	Microsoft::WRL::ComPtr<IDxcBlobUtf8> pErrors = nullptr;
	pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
	// Note that d3dcompiler would return null if no errors or warnings are present.
	// IDxcCompiler3::Compile will always return an error buffer, but its length
	// will be zero if there are no warnings or errors.
	if (pErrors != nullptr && pErrors->GetStringLength() != 0)
		OutputDebugStringA(pErrors->GetStringPointer());

	HRESULT hrStatus;
	pResults->GetStatus(&hrStatus);
	if (FAILED(hrStatus))
	{
		OutputDebugStringA("Compilation Failed\n");
		return;
	}

	//
	// Save shader binary.
	//
	Microsoft::WRL::ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
	pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
	if (pShader != nullptr)
	{
		FILE* fp = NULL;

		_wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
		fwrite(pShader->GetBufferPointer(), pShader->GetBufferSize(), 1, fp);
		fclose(fp);
	}

	//
	// Save pdb.
	//
	Microsoft::WRL::ComPtr<IDxcBlob> pPDB = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlobUtf16> pPDBName = nullptr;
	pResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
	{
		FILE* fp = NULL;

		// Note that if you don't specify -Fd, a pdb name will be automatically generated.
		// Use this file name to save the pdb so that PIX can find it quickly.
		_wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
		fwrite(pPDB->GetBufferPointer(), pPDB->GetBufferSize(), 1, fp);
		fclose(fp);
	}

}

ComputePipeline::ComputePipeline() :Pipeline()
{

}
void ComputePipeline::Init(std::shared_ptr<D3DHelper::Device> device)
{
	m_device = device;
	InitShaders();
	InitRootSignature();
	InitPSO();
	InitResources();
}
void ComputePipeline::CompileComputeShader(std::wstring shader_dir, std::wstring shader_name, std::wstring entry, Microsoft::WRL::ComPtr<ID3DBlob>* out_shader)
{
	std::wstring hlsl = shader_dir + shader_name + L".hlsl";
	std::wstring pdb = shader_dir + shader_name + L".pdb";
	std::wstring cso = shader_dir + shader_name + L".cso";

	LPCWSTR hlsl_file_name = hlsl.c_str();
	LPCWSTR pszArgs[] =
	{
		hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
		L"-E", entry.c_str(),              // Entry point.
		L"-T", L"cs_6_7",            // Target.
		L"-Zi",L"-Qembed_debug",                      // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#else
			L"-O3",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", pdb.c_str(),     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",cso.c_str(),
			L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
	};
	Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
	CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
	shader_out.As(out_shader);
}

void ComputePipeline::CompileComputeShader(std::wstring shader_dir, std::wstring shader_name, std::wstring entry, const std::vector<std::wstring>& add_arg, Microsoft::WRL::ComPtr<ID3DBlob>* out_shader)
{
	std::wstring hlsl = shader_dir + shader_name + L".hlsl";
	std::wstring pdb = shader_dir + shader_name + L".pdb";
	std::wstring cso = shader_dir + shader_name + L".cso";

	LPCWSTR hlsl_file_name = hlsl.c_str();
	std::vector<LPCWSTR> args = {
		hlsl.c_str(),
		L"-E", entry.c_str(),              // Entry point.
		L"-T", L"cs_6_7",            // Target.
		L"-Zi",L"-Qembed_debug",                      // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#else
			L"-O3",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
		L"-Fd", pdb.c_str(),     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
		L"-Fo",cso.c_str(),
		L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
	};
	for (const auto& arg : add_arg)
	{
		args.push_back(arg.c_str());
	}
	Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
	CompileShaingModel6(args.data(), args.size(), hlsl_file_name, shader_out);
	shader_out.As(out_shader);

}
void ComputePipeline::InitShaders()
{
	CompileComputeShader(m_shader_dir, m_shader_name, L"main", &m_compute_shader);
}
void ComputePipeline::InitPSO()
{
	D3D12_COMPUTE_PIPELINE_STATE_DESC pso_desc = {};
	pso_desc.CS = CD3DX12_SHADER_BYTECODE(m_compute_shader.Get());
	pso_desc.pRootSignature = m_root_signature.Get();
	auto psoStream = CD3DX12_PIPELINE_STATE_STREAM(pso_desc);
	D3D12_PIPELINE_STATE_STREAM_DESC streamDesc;
	streamDesc.pPipelineStateSubobjectStream = &psoStream;
	streamDesc.SizeInBytes = sizeof(psoStream);
	ThrowIfFailed(m_device->GetDevice()->CreatePipelineState(&streamDesc, IID_PPV_ARGS(&m_pipeline_state)));
}
void ComputePipeline::CommitDescriptors(D3DHelper::StaticDescriptorStack(&param_stacks)[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES])
{
	param_stacks[D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV].push_back(m_heaps[D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV],
		0, m_heaps[D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV].GetDescriptorNum());
}
void ComputePipeline::Draw(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list,
	D3DHelper::StaticDescriptorStack(&param_stacks)[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES],
	int buffer_index,
	const ViewInfo* p_view,
	const RenderProxy* proxy)
{
	assert(false);
}



DefaultGraphicPipeline::DefaultGraphicPipeline()
{

}

void DefaultGraphicPipeline::InitShaders()
{
	{
		LPCWSTR hlsl_file_name = L"./shader/default/vertex_shader.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"VSMain",              // Entry point.
			L"-T", L"vs_6_0",            // Target.
			L"-Zi",L"-Qembed_debug",        // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/default/vertex_shader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/default/vertex_shader.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_vertex_shader);
	}

	{
		LPCWSTR hlsl_file_name = L"./shader/default/pixel_shader.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"PSMain",              // Entry point.
			L"-T", L"ps_6_0",            // Target.
			L"-Zi", L"-Qembed_debug",                     // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/default/pixel_shader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/default/pixel_shader.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_pixel_shader);
	}

}

void DefaultGraphicPipeline::InitRootSignature()
{
	assert(m_device);
	CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
	Microsoft::WRL::ComPtr<ID3DBlob> serialized_signature_desc;
	Microsoft::WRL::ComPtr<ID3DBlob> error;
	ThrowIfFailed(D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &serialized_signature_desc, &error));
	ThrowIfFailed(m_device->GetDevice()->CreateRootSignature(0, serialized_signature_desc->GetBufferPointer(), serialized_signature_desc->GetBufferSize(), IID_PPV_ARGS(&m_root_signature)));

}
void DefaultGraphicPipeline::InitPSO()
{
	assert(m_device);
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
	};

	// Describe and create the graphics pipeline state object (PSO).
	D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {};
	psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
	psoDesc.pRootSignature = m_root_signature.Get();
	psoDesc.VS = CD3DX12_SHADER_BYTECODE(m_vertex_shader.Get());
	psoDesc.PS = CD3DX12_SHADER_BYTECODE(m_pixel_shader.Get());
	psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
	psoDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	psoDesc.SampleMask = UINT_MAX;
	psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	psoDesc.NumRenderTargets = 1;
	psoDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	psoDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT;
	psoDesc.SampleDesc.Count = 1;
	ThrowIfFailed(m_device->GetDevice()->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&m_pipeline_state)));
}

void DefaultGraphicPipeline::InitResources()
{
	;
}

void DefaultGraphicPipeline::Init( std::shared_ptr<D3DHelper::Device> device)
{
	m_device = device;
	InitShaders();
	InitRootSignature();
	InitPSO();
	InitResources();
}

void DefaultGraphicPipeline::SetRootSignature(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list, const ViewInfo* p_view, const RenderProxy* proxy, 
	D3D12_GPU_DESCRIPTOR_HANDLE* stack_bottom)
{
	command_list->SetGraphicsRootSignature(m_root_signature.Get());
}

void DefaultGraphicPipeline::CommitDescriptors(D3DHelper::StaticDescriptorStack(&param_stacks)[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES])
{
	/*
	for (int i = 0; i < D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES; i++)
	{
		param_stacks[i].push_back(m_heaps[i], 0, m_heaps[i].GetDescriptorNum());
	}
	*/
}

void DefaultGraphicPipeline::Draw(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list,
	D3DHelper::StaticDescriptorStack(&param_stacks)[D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES],
	int buffer_index,
	const ViewInfo* p_view,
	const RenderProxy* proxy)
{
	auto triangle_render_proxy = dynamic_cast<const TriangleRenderProxy*>(proxy);
	assert(triangle_render_proxy);

	command_list->RSSetViewports(1, &p_view->m_viewport);
	command_list->RSSetScissorRects(1, &p_view->m_scissor_rect);
	command_list->OMSetRenderTargets(1, &p_view->render_target_view, false, &p_view->depth_stencil_view);
	command_list->SetPipelineState(m_pipeline_state.Get());
	//D3D12_GPU_DESCRIPTOR_HANDLE param_stack_bottom[] = { param_stacks[0].GetTopGPU(),};
	triangle_render_proxy->CommitParams(command_list, param_stacks);
	SetRootSignature(command_list, p_view,proxy,nullptr);
	CommitDescriptors(param_stacks);
	command_list->DrawInstanced(triangle_render_proxy->GetVertexCountPerInstance(), 1, 0, 0);
}



void StaticMeshGraphicPipeline::InitShaders()
{
	{
		LPCWSTR hlsl_file_name = L"./shader/triangle/vertex_shader.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"VSMain",              // Entry point.
			L"-T", L"vs_6_0",            // Target.
			L"-Zi",L"-Qembed_debug",        // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/triangle/vertex_shader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/triangle/vertex_shader.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_vertex_shader);
	}

	{
		LPCWSTR hlsl_file_name = L"./shader/triangle/pixel_shader.hlsl";
		LPCWSTR pszArgs[] =
		{
			hlsl_file_name,            // shader source file name for error reporting and for PIX shader source view.  
			L"-E", L"PSMain",              // Entry point.
			L"-T", L"ps_6_0",            // Target.
			L"-Zi", L"-Qembed_debug",                     // Enable debug information (slim format)
#if defined(_DEBUG)
			L"-Od",
#endif
			//L"-D", L"MYDEFINE=1",        // A single define.
			L"-Fd", L"./shader/triangle/pixel_shader.pdb",     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
			L"-Fo",L"./shader/triangle/pixel_shader.cso"
		};
		Microsoft::WRL::ComPtr<IDxcBlob> shader_out;
		CompileShaingModel6(pszArgs, _countof(pszArgs), hlsl_file_name, shader_out);
		shader_out.As(&m_pixel_shader);
	}

}

void StaticMeshGraphicPipeline::InitRootSignature()
{
	assert(m_device);
	CD3DX12_ROOT_PARAMETER rootParameters[2];
	rootParameters[0].InitAsConstants(sizeof(ViewBuffer) / 4, 0, 0, D3D12_SHADER_VISIBILITY_VERTEX);
	rootParameters[1].InitAsConstants(sizeof(BatchBuffer) / 4, 1, 0, D3D12_SHADER_VISIBILITY_VERTEX);

	CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init(_countof(rootParameters), rootParameters, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);
	Microsoft::WRL::ComPtr<ID3DBlob> serialized_signature_desc;
	Microsoft::WRL::ComPtr<ID3DBlob> error;
	ThrowIfFailed(D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &serialized_signature_desc, &error));
	ThrowIfFailed(m_device->GetDevice()->CreateRootSignature(0, serialized_signature_desc->GetBufferPointer(), serialized_signature_desc->GetBufferSize(), IID_PPV_ARGS(&m_root_signature)));
}

void StaticMeshGraphicPipeline::SetRootSignature(Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> command_list, const ViewInfo* p_view, const RenderProxy* proxy, 
	D3D12_GPU_DESCRIPTOR_HANDLE* stack_bottom)
{
	command_list->SetGraphicsRootSignature(m_root_signature.Get());

	ViewBuffer view_buffer;
	view_buffer.view_transform = p_view->view_matrix;
	view_buffer.project_transform = p_view->project_matrix;
	view_buffer.viewport_size = { int(p_view->m_viewport.Width),int(p_view->m_viewport.Height) };
	BatchBuffer batch_buffer;
	batch_buffer.world_transform = proxy->world_transform;

	command_list->SetGraphicsRoot32BitConstants(0, sizeof(ViewBuffer) / 4, &view_buffer, 0);
	command_list->SetGraphicsRoot32BitConstants(1, sizeof(BatchBuffer) / 4, &batch_buffer, 0);
}